[ 파일 만들기 ]
    1. [src]폴더 오른쪽 클릭
    2. [새로만들기]
        1. java 클래스
        2. 파일 ( 파일명.txt )
        3. 패키지 ( 폴더 )

[ 자바 클래스 파일 생성 ]
    1. [src]폴더 오른쪽 클릭
    2. [새로만들기] -> [ 패키지 ] -> (강의기준 day01~ )
    3. [특정폴더] 오른쪽 클릭 -> [ 새로만들기 ] -> [java클래스]
        * 클래스 파일 명은 첫글자를 무조건 대문자로 시작.
        예) Example1

[ 자바 구동 원리 ]
    1. [코딩] 개발자는 .java 파일내 자바 문법 작성한다.
    - Example1.java ( 파일 )
    2. [실행] .java 파일 -- 컴파일(번역/해석) ---> .class 파일(바이트) 생성
    3. [처리] (컴퓨터가) .class 파일 처리한다.

[ 주석 ]
    HTML : <!-- 주석처리 -->
    CSS : /* 주석처리 */
    JS/JAVA :   // 한줄주석
                /*  여러줄주석 */

[ 자바 활용처 ]
    1. 소프트웨어 : javafx툴 활용, 등등
    2. 웹 : JSP , Spring 등등
    3. 앱 : 안드로이드 등등

[ 자바 코드 실행 ]
    - 자바는 클래스 단위로 컴파일 되고 , 컴파일된 코드는 main함수 부터 읽어서(스레드) 처리한다.

[ 리터럴 ]
    - 3 , 3.14 , 'a' , "ABC" , true 등등
    1. 정의 : 키보드 로 부터 입력한 자료
    2. 종류
        정수(int) , 실수(double) , 문자('') , 문자열("") , 논리(boolean)

[ 기본타입 ]
    1. 정의 : 자료들의 분류
    2. 목적 : 효율적인 자료 처리 (*분리수거)
    3. 종류(8가지)
        [정수]       byte        1바이트        -128 ~ 127
                    short       2바이트        +-3만정도 까지
                    int         4바이트        +-21억정도 까지 (*리터럴정수)
                    long        8바이트        +-21억정도 이상 , 리터럴정수 뒤에 L/l 붙이기
        [실수]       float       4바이트        소수점8자리 표현 , 리터럴실수 뒤에 F/f 붙이기
                    double      8바이트        소수점17자리 표현(*리터럴실수)
        [논리]       boolean     1바이트        true/false
        [문자]       char        2바이트        유니코드 , ' '작은따옴표 감싼 문자1개
                    *String     클래스         클래스 , " " 큰따옴표 감싼 문자여러개
[출력함수]
    1. System.out.print();                                      : 출력
    2. System.out.println();                                    : 출력후 줄바꿈
    3. System.out.printf( "형식문자1 형식문자2" , 값1 , 값2 );    : 서식(형식) 맞춤 출력
        - 형식문자 : %s 문자열 , %d 정수 , %c 문자 , %f 실수
        - 자릿수 :
            %자릿수d : 자릿수만큼 자릿수 차지 , 만일 비어 있으면 공백 , 오른쪽 정렬
            %-자릿수d : 자릿수만큼 자릿수 차지 , 만일 비어 있으면 공백 , 왼쪽 정렬
            %0자릿수d : 자릿수만큼 자릿수 차지 , 만일 비어 있으면 0채움
        - 소수점 자릿수 :
            %전체자릿수.소수점자릿수f : (소수점포함)전체 자릿수 만큼 자릿수 차지

[ 이스케이프/제어 문자 ] : 특수문자에 기능이 포함
    \n 줄바꿈 , \t 들여쓰기 , \\ 백슬래시 출력 , \' 작은따옴표 출력 , \" 큰따옴표 출력

[ (변수)타입변환 ] , **다형성**
    1. 자동(묵시적) 타입변환
        (1) byte -> short/char -> int -> long -> float -> double
        (2) 메모리 크기가 작은 것 에서 큰 것으로 변환 가능!
        (3) 연산결과
            - 두 항 중에 더 큰 항의 타입으로 결과 반환
            - 단] int 이하는 무조건 int 반환
    2. 강제(명시적) 타입변환
        (1) double -> float -> long -> int -> short/char -> byte
        (2) 메모리 크기가 큰 것 에서 작은 것으로 변환 가능!
        (3) (변환할타입명)변수명;
        (4) !! 자료의 손실이 생길 수 있다.

[ 입력함수 ]
    1. 콘솔화면에서 키보드로 부터 입력받는 방법
    2. 사용법
        (1) 입력객체 생성 : new Scanner( System.in);
            Scanner 변수명 = new Scanner( System.in);
            * 주의할점 : Scanner 입력시 자동완성 권장. 안할경우 : 클래스 위에 import java.util.Scanner; 직접 작성
            * import란 다른 클래스(코드정보) 호출
        (2) 입력함수
            .next()             : 입력받은 자료를 문자열(String)로 반환 , 띄어쓰기 불가능
            .nextLine()         : 입력받은 자료를 문자열(String)로 반환 , 띄어쓰기 가능 ,
                * 문제점 : .nextLine() 앞 코드 에 다른 next() 존재할 경우 의미없는 nextLine() 필요하다.
            .nextByte()         : 입력받은 자료를 정수(byte)로 반환
            .nextShort()        : 입력받은 자료를 정수(short)로 반환
            .nextInt()          : 입력받은 자료를 정수(int)로 반환
            .nextLong()         : 입력받은 자료를 정수(long)로 반환
            .nextFloat()        : 입력받은 자료를 실수(float)로 반환
            .nextDouble()       : 입력받은 자료를 실수(double)로 반환
            .nextBoolean()      : 입력받은 자료를 논리(boolean)로 반환
            .next().charAt(0)   : 입력받은 자료를 첫글자 문자(char)1개 반환
[ 연산자 ]
    1. 산술연산자 : +더하기 -빼기 *곱하기 /나누기 %나머지
    2. 연결연산자 : +연결
    3. 비교연산자 : >초과 >=이상 <미만 <=이하 ==같다 !=같지않다
    4. 논리연산자 : &&이면서 ||이거나 !부정
    5. 증감연산자 : ++변수명 변수명++ --변수명 변수명--
    6. 대입연산자 : =대입 +=더한후대입 연산후대입(+= *= -= /= %= )
    7. 삼항연산자 : 조건 ? 참 : 거짓
    8. 문자열비교 : "문자열A".equals("문자열B")

[ 조건문 ]
    1. 조건에 따른 결과(true/false)의 코드 흐름 제어 ,
    2. 종류)
        (1) if( 조건문 ) 참일때명령어;
        (2) if( 조건문 ){ 참일때명령어1; 참일때명렁어2; }
        (3) if( 조건문 ){ 참일때명령어; }
            else{ 거짓일때명령어; }
        (4) if( 조건문1 ) { 참1일떄명령어;}
            else if( 조건문2 ) { 참2일때명령어; }
            else if( 조건문3 ) { 참3일때명령어; }
            else{ 거짓일때명령어; }
        (5) if( 조건문1 ) { 참1일때명령어; }
            if( 조건문2 ) { 참2일때명령어; }
            if( 조건문3 ) { 참3일때명렁어; }
        (6) if( 조건문1 ) {
                if( 조건문2 ){ }
                else{ }
            }else{ }

[반복문]
                1. 조건에 따른 결과가 총족(true) 했을때 (반복)코드 실행
                2. 형태
                    for( 초기값 ; 조건문 ; 증감식 ){
                        실행문;
                    }
                    - 초기값 : 반복문에서 사용되는 변수 *주로 반복횟수                  , int i = 1;
                    - 조건문 : 반복변수의 조건문 *주로 반복횟수제한                     , i <= 10;
                    - 증감식 : 반복변수의 증(가) 또는 감(소) 변화 식 *주로 반복횟수 증감 , i++
                    - 실행문 : 조건 충족시 실행되는 코드/명령어;
                3. 실행순서
                    1) 초기값 -> 2)조건문 -> 3) 실행문 -> 4)증감식
                              -> 5)조건문 -> 6) 실행문 -> 7)증감식
                               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                               -> !) 조건이 false 이면 반복문 종료
               4. for중첩가능 : 상위 for문이 1회전 마다 하위 for문의 전체 회전
                    for( ) {
                        for( ) { }
                    }
               5. 주요 키워드 :
                    1) break;       : 가장 가까운 반복문 {} 종료/탈출
                    2) continue;    : 가장 가까운 반복문(증감식) 이동
               6. 무한루프
                    방법1) for( ; ; ){ }
                    방법2) while( true ){ }

[ 배열 ]
                1. 정의 : *동일한* 자료형(타입)의 여러개 데이터를 순서대로 저장하는 타입
                2. 특징
                    1) 동일한 타입 : 서로 다른 타입의 데이터를 같은 배열에 저장할 수 없다.
                    2) 고정 길이 : 배열은 한 번 생성되면 길이를 수정할 수 없다.
                    3) 요소 초기값 : 요소의 초기값이 없으면 자동으로 기본값 대입
                        정수 : 0 , 실수 : 0.0 , 논리 : false , 객체(배열) : null
                3. 사용법
                    1) 선언/생성
                        (1) new 타입[길이];        ,    int[] 변수명 = new int[ 3 ];
                        (2) { 값1, 값2 , 값3 }     ,    double[] 변수명 = { 3.14 , 5.1 , 78.67 }
                    2) 호출
                        (1) 변수명                         ,  배열(객체)의 주소값
                        (2) Arrays.toString( 변수명 );     ,  배열내 요소 값 들을 문자열로 반환
                        (3) 변수명[인덱스]
                            * 인덱스란? 배열내 저장된 요소들의 순서번호 , 0번부터 시작
                            * 변수명.length : 배열내 요소개수 반환 , 배열의길이
                    3) 수정
                        (1) 변수명 = new 타입[ 3 ];          , 전체 배열 수정
                        (2) 변수명[인덱스] = 새로운값;        , 특정 인덱스의 값 수정

                    4) 삭제/추가 * 특정한 요소 삭제/추가 는 존재하지 않는다. 자바 배열은 *고정길이* 이므로 중간에 요소 총개수 변경할수 없다.
                    5) 배열과 반복문
                        (1) 일반 for문
                            for( int index = 0 ; index <= 배열변수명.length - 1 ; index++ ){
                                타입 변수명 = 배열변수명[index];
                            }
                        (2) 향상된 for문 , 인덱스 없이 배열내 요소값 하나씩 변수에 대입 반복
                            for( 타입 변수명 : 배열변수명 ){

                            }

[ 클래스 와 객체 ]
                1) 객체 : '주체'가 아닌 의사나 행위를 미치는 대상
                2) 객체 종류 : 모든것들 , 속성과 기능을 정의 한다면
                    - 사람(물리), 주문(논리) , 안경(물리) , 공기(물리) , 강의(논리) 등등
                3) 객체지향 프로그래밍 : 개발자(주체)가 컴퓨터 안에서 (객체)대상 만들기
                4) 클래스 : 객체를 만들기 위한 설계도 , 속성 과 기능 코드로 표현
                    - 속성 : 대상의 본질적인 특징/성질/특성    -> 멤버변수
                    - 기능 : 대상의 작동/행위/이벤트          -> 멤버함수 , 메소드
                * 자바의 모든 코드는 클래스 단위로 컴파일 한다. *
                5) 생활속 예시
                    (1) 학생 객체 만들기
                        1. 클래스 정의한다.    즉] 속성 과 기능 만들기 --> 특징 , 이벤트 만들기
                            -> 학생에게 속성 부여 : 학번 , 이름 , 전화번호
                            -> 학생에게 이벤트 부여 : 공부하기() , 밥먹기() , 잠자기()
                        2. 객체 정의한다.
                            new 학생();
                        3. 객체내 멤버변수, 메소드 접근
                            학생.학번

                    (2) 붕어빵 객체 만들기
                        1. 클래스(붕어빵틀) 정의한다.
                            -> 속성 : 내용물 , 가격
                            -> 이벤트 : 굽기() , 꺼내기() , 판매()
                        2. 객체 정의한다.
                            new 붕어빵틀();
                        4. 객체내 멤버변수
                            붕어빵.내용물

                6) 사용법
                    < 클래스 만들기 >
                        방법1) class 클래스명{ 타입 멤버변수명; }
                        방법2)
                    < 객체 만들기 >
                        방법1) new 클래스명();
                        방법2) 클래스명 변수명 = new 클래스명();
                    < 객체 내 멤버변수 호출 : .(접근연산자) >
                        변수명.멤버변수
                    < 객체 내 멤버변수 값 수정 >
                        변수명.멤버변수 = 새로운값
                    < 객체 내 멤버변수 추가 / 삭제 불가능 >
                        - 실행 도중에 클래스 정보를 추가 / 삭제 할 수 없다. 단점] 유연성 떨어짐